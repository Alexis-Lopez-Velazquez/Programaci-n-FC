# -*- coding: utf-8 -*-
"""Proyecto Graficas_PageRank.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13b_KN2Wv5Q_6ZIjfGZgIGDR08A59f6qW

Proyecto: Algotimo PageRank

Lopez Velazquez Alexis Eduardo
"""

import numpy as np #Se importan las librerias que usaremos
import pandas as pd
#Ahora definimos las dos clases que usaremos:
class Grafica:
  '''
  La clase representa a una digrafica G(X,A) formada por un conjunto de nodos X
  y una relacion "~" en dicho conjunto, la relacion i~j se representa con el
  arco (i,j), el conjunto de arcos es A, la clase recibe como parametros para su
  inicializacion una lista de nodos representados por indices iniciando en 0
  y una lista de tuplas, cada tupla (i,j) representa un arco de la digrafica.
  '''
  def __init__(self,nodos,arcos):
    '''
    Con la lista de nodos y arcos como parametros se crea la matriz
    de adyacencia de la digrafica, dicha matriz de tamano longitud de nodos por
    longitud de nodos, se inicializa con ceros y despues se colocan unos en las
    posiciones (i,j) correspondientes a los arcos.
    '''
    self.matriz=np.zeros((len(nodos),len(nodos))) #se inicia la matriz con ceros
    for arco in arcos: #para cada arco (i,j)
      self.matriz[arco[0],arco[1]]=1 #se pone 1 en la entrada (i,j) de la matriz
  def __str__(self):
    '''
    El metodo str de la clase, imprime la matriz de adyacencia de la digrafica.
    '''
    return str(self.matriz)
  def quitar_arco(self,arco):
    '''
    Este metodo recibe como parametro un arco (i,j) y lo elimina de la matriz
    de adyacencia, sustituyendo el 1 de la posicion (i,j) por un 0.
    '''
    self.matriz[arco[0],arco[1]]=0
  def agregar_arco(self,arco):
    '''
    Este metodo recibe como parametro un arco (i,j) y lo agrega a la matriz de
    adyacencia, sustituyendo el elemento de la posicion (i,j) por un 1.

    '''
    self.matriz[arco[0],arco[1]]=1
  def num_nodos(self):
    '''
    Este metodo devuelve el numero de nodos de la digrafica, dicho numero
    coincide con el numero de renglones o columnas de la matriz de adyacencia.
    '''
    return len(self.matriz)
  def num_arcos(self):
    '''
    Este metodo devuelve el numero de arcos de la digrafica, dicho numero
    coincide con la suma de los elementos de la matriz de adyacencia, pues cada
    arco se representa con un 1 en dicha matriz y el resto son ceros.
    '''
    return int(self.matriz.sum()) #Con sum() se hace la suma de los elementos
  def agregar_nodo(self):
    '''
    Este metodo aumenta en uno el numero de filas y columnas de la matriz de
    adyacencia, representando un nuevo nodo en la digrafica.
    '''
    vertical=np.zeros((len(self.matriz),1)) #se crea un vector columna de ceros
    horizontal=np.zeros((1,len(self.matriz)+1)) #vector renglon de ceros
    self.matriz=np.vstack((np.hstack((self.matriz,vertical)),horizontal))
    #el metodo hstack pega la matriz con el vector columna de ceros
    #el metodo vstack apila la  matriz anterior con el renglon de ceros
  def quitar_nodo(self,nodo):
    '''
    Este metodo recibe un nodo (indice) y elimina el renglon y columna
    correspondientes a dicho nodo de la matriz de adyacencia.
    '''
    self.matriz=np.delete(self.matriz,nodo,axis=0) #se elimina el renglon
    self.matriz=np.delete(self.matriz,nodo,axis=1) #se elimina la columna


class Red(Grafica):
  '''
  Esta clase hereda de la clase Grafica y representa la red R=(G(X,A),f), donde
  la grafica G(X,A) tiene por conjunto de nodos a X, un conjunto de paginas web,
  y la relacion i~j representada por el conjunto de arcos A, es la relacion "i"
  cita a la pagina "j" (Back-link) y la funcion f(i,j) es la funcion que asigna
  peso a cada Back-link, la clase recibe como parametros para su inicializacion
  la ruta de archivo del excel con los datos asociados a G(X,A).

  '''
  @classmethod
  def construccion_grafica(cls,ruta_de_archivo):
    '''
    Este metodo abstracto recibe como parametro la ruta de archivo del excel
    con los datos asociados a G(X,A) (data_frame) y devuelve las listas de
    nodos y arcos, ademas construye y devuelve un vector pi_s cuya k-esima
    entrada es 0 si la k-esima pagina no tiene terminacion .ru y es 1/s en caso
    contrario, donde s es el numero de paginas con terminacion .ru.

    '''
    data_frame=pd.read_excel(ruta_de_archivo)
    Nodos=(list(range(len(data_frame["Index"])))) #lista de nodos
    l1=list(data_frame["Cited by"]) #De l1 se obtienen los arcos
    Arcos=[]
    for j in range(len(l1)): #Con el ciclo recorremos todas las relaciones i~j
      for i in l1[j].split(','): #Con split separamos los indices 'i' de l1
        Arcos.append((int(i)-1,j)) #'i' cita a la pagina'j', el-1 es por desfase
    l2=list(data_frame["Website"])#En lo siguiente construimos al vector pi_s
    Contador_s=0 #Para contar cuantos sitios tienen terminacion .ru
    pi_s=np.zeros(len(l2))#Se inicia el vector en ceros
    for j,sitio in enumerate(l2):#Recorremos el indice y sitio asociado a la vez
      if sitio.endswith(".ru"):#Se verifica que la terminacion del sitio sea .ru
        pi_s[j]=1 #Se cambia el 0 por 1
        Contador_s+=1
    pi_s=pi_s/Contador_s #Se obtiene a pi_s

    return Nodos, Arcos, pi_s
  def __init__(self,ruta_de_archivo):
    '''
    Se inicializa la instancia de Red, recibe como parametro la ruta de archivo
    del excel con el data frame asociado a G(X,A) y con el metodo abstracto
    "construccion_grafica" se obtiene la lista de nodos y arcos, para poder
    inicializar la instancia de la clase Grafica de nuestra red.
    '''
    Nodos, Arcos, pi_s=self.construccion_grafica(ruta_de_archivo)
    super().__init__(Nodos,Arcos) #Con super() se ejecuta el __init__ de la
    #clase padre: Grafica.
  def pagerank(self,epsilon,d):
    '''
    Este metodo de la clase Red implementa el algoritmo PageRank a la red,
    sus parametros son epsilon>0 el cual sera el orden de convergencia para los
    vectores de pesos y d un numero entre 0 y 1 el cual sirve como parametro de
    proximidad entre las matrices de pesos P y U, el metodo devuelve dos
    vectores de pesos, el primero corresponde a cuando el algoritmo se inicia
    con el vector (1/n,...,1/n) y solo se itera con la matriz P (d=1), el
    segundo vector corresponde a cuando el algoritmo se inicia con el vector
    pi_s y se itera con la matriz dP+(1-d)U
    '''
    P=np.zeros_like(self.matriz)
    for i in range(len(self.matriz)):#Hacemos a P, renglon a renglon
      P[i:]=self.matriz[i]/self.matriz[i].sum()
    pi=np.ones((1,len(self.matriz)))/len(self.matriz) #Hacemos al vector de 1/n
    pi_1=pi@P #Primera iteracion
    while np.linalg.norm(pi-pi_1)>epsilon: #seguimos iterando hasta que los
    #vectores esten epsilon cercanos en norma
      pi=pi_1
      pi_1=pi@P
    #Ahora hacemos la modificacion para pregunta 2 y 3:
    U=np.ones_like(self.matriz)/len(self.matriz) #definimos la matriz U
    matriz_convexa=d*P+(1-d)*U
    pi_s=self.construccion_grafica("/content/drive/MyDrive/Colab Notebooks/Web.xlsx")[2]
    pi_ru=pi_s@matriz_convexa #Primera iteracion
    while np.linalg.norm(pi_s-pi_ru)>epsilon: #se itera hasta orden epsilon
      pi_s=pi_ru
      pi_ru=pi_s@matriz_convexa
    return pi,pi_s #Devolvemos los vectores iterados
if __name__ == '__main__' : #Se implementa el main del programa
  r=Red("/content/drive/MyDrive/Colab Notebooks/Web.xlsx") #Se inicializa la red
  print(r.num_nodos()) #Hay 26 nodos
  print(r.num_arcos()) #Hay 93 arcos
  #Tomaremos epsilon=1e-6
  #Primer pregunta:
  vector_pesos_1=r.pagerank(1e-6,1)[0] #Se obtiene el vector de pesos
  print(vector_pesos_1)
  #Notamos que el sitio con la mayor importancia (peso mayor) es el sitio 26
  #federalreserve.gov
  #Segunda pregunta:
  vector_pesos_2=r.pagerank(1e-6,1)[1] #Vector de pesos con d=1
  print(vector_pesos_2)
  #Se obtiene que el sitio mas relevante es el 24: vedomosti.ru
  #Tercera pregunta:
  vector_pesos_3=r.pagerank(1e-6,0.85)[1] #Vector de pesos con d=0.85
  print(vector_pesos_3) #El sitio mas relevante es el 26
  vector_pesos_4=r.pagerank(1e-6,0.5)[1] #Vector de pesos con d=0.50
  print(vector_pesos_4) #El sitio mas relevante es el 26